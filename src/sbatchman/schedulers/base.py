# src/exp_kit/schedulers/base.py
from abc import ABC, abstractmethod
from typing import List, Optional, Dict, Tuple
import subprocess

class Scheduler(ABC):
  """Abstract base class for all job schedulers."""

  def generate_script(self, name: str, **kwargs) -> str:
    """
    Generates the full submission script using a template method pattern.
    """
    header = [
      "#!/bin/bash",
      "# ======================================================================",
      "# This file was automatically generated by SbatchMan.",
      "# Manual edits are possible but should be done with care.",
      "# ======================================================================\n",
    ]

    # Get scheduler-specific lines from the subclass implementation.
    scheduler_directives = self._generate_scheduler_directives(name, **kwargs)

    # Add a command to CD into the submission directory
    working_dir_setup = [
      "\n# Change to the submission directory",
      'cd "{CWD}"',
    ]

    # Handle common environment variables.
    env_vars = ["\n# Environment variables"]
    if envs := kwargs.get("env"):
      for env_var in envs:
        env_vars.append(f"export {env_var}")
    
    # The user command part is also common.
    footer = [
      "\n# User command",
      'CMD="$1"',
      'echo "Running command: $CMD"',
      'eval $CMD',
    ]

    all_lines = header + scheduler_directives + working_dir_setup + env_vars + footer
    return "\n".join(all_lines)

  @abstractmethod
  def _generate_scheduler_directives(self, name: str, **kwargs) -> List[str]:
    """
    (Abstract) Generates the list of scheduler-specific directive lines.
    This must be implemented by subclasses.
    """
    pass

  @abstractmethod
  def get_submit_command(self) -> str:
    """Returns the command used to submit a job (e.g., 'sbatch')."""
    pass

  @abstractmethod
  def parse_job_id(self, submission_output: str) -> str:
    """Parses the job ID from the submission command's output."""
    pass

  def get_status(self, job_ids: List[str]) -> Dict[str, Tuple[str, Optional[str]]]:
    """
    Checks the status of a list of job IDs.

    Returns:
        A dictionary mapping job_id to a tuple of (status, queue_info).
        Status can be: QUEUED, RUNNING, FINISHED, FAILED, UNKNOWN.
        queue_info can be the position in queue, or None.
    """
    if not job_ids:
      return {}
    try:
      return self._get_status_from_scheduler(job_ids)
    except (subprocess.CalledProcessError, FileNotFoundError):
      return {job_id: ("UNKNOWN", None) for job_id in job_ids}

  @abstractmethod
  def _get_status_from_scheduler(self, job_ids: List[str]) -> Dict[str, Tuple[str, Optional[str]]]:
    """Scheduler-specific implementation for checking job status."""
    pass